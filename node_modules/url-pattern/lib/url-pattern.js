// Generated by CoffeeScript 1.9.1
var indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

(function(root, factory) {
  if (('function' === typeof define) && (define.amd != null)) {
    return define([], factory);
  } else if (typeof exports !== "undefined" && exports !== null) {
    return module.exports = factory();
  } else {
    return root.UrlPattern = factory();
  }
})(this, function() {
  var UrlPattern;
  UrlPattern = function(arg, separator) {
    if (arg instanceof UrlPattern) {
      this.isRegex = arg.isRegex;
      this.regex = arg.regex;
      this.names = arg.names;
      return this;
    }
    this.isRegex = arg instanceof RegExp;
    if (!(('string' === typeof arg) || this.isRegex)) {
      throw new TypeError('argument must be a regex or a string');
    }
    [':', '*'].forEach(function(forbidden) {
      if (separator === forbidden) {
        throw new Error("separator can't be " + forbidden);
      }
    });
    if (this.isRegex) {
      this.regex = arg;
    } else {
      this.regex = new RegExp(this.toRegexString(arg, separator));
      this.names = this.getNames(arg, separator);
    }
    return this;
  };
  UrlPattern.prototype.match = function(url) {
    var bound, captured, i, j, len, match, name, value;
    match = this.regex.exec(url);
    if (match == null) {
      return null;
    }
    captured = match.slice(1);
    if (this.isRegex) {
      return captured;
    }
    bound = {};
    for (i = j = 0, len = captured.length; j < len; i = ++j) {
      value = captured[i];
      name = this.names[i];
      if (value == null) {
        continue;
      }
      if (name === '_') {
        if (bound._ == null) {
          bound._ = [];
        }
        bound._.push(value);
      } else {
        bound[name] = value;
      }
    }
    return bound;
  };
  UrlPattern.prototype.escapeForRegex = function(string) {
    return string.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
  };
  UrlPattern.prototype.getNames = function(arg, separator) {
    var escapedSeparator, name, names, regex, results;
    if (separator == null) {
      separator = '/';
    }
    if (arg instanceof RegExp) {
      return [];
    }
    escapedSeparator = this.escapeForRegex(separator);
    regex = new RegExp("((:?:[^" + escapedSeparator + "\(\)]+)|(?:[\*]))", 'g');
    names = [];
    results = regex.exec(arg);
    while (results != null) {
      name = results[1].slice(1);
      if (name === '_') {
        throw new TypeError(":_ can't be used as a pattern name in pattern " + arg);
      }
      if (indexOf.call(names, name) >= 0) {
        throw new TypeError("duplicate pattern name :" + name + " in pattern " + arg);
      }
      names.push(name || '_');
      results = regex.exec(arg);
    }
    return names;
  };
  UrlPattern.prototype.escapeSeparators = function(string, separator) {
    var escapedSeparator, regex;
    if (separator == null) {
      separator = '/';
    }
    escapedSeparator = UrlPattern.prototype.escapeForRegex(separator);
    regex = new RegExp(escapedSeparator, 'g');
    return string.replace(regex, escapedSeparator);
  };
  UrlPattern.prototype.toRegexString = function(string, separator) {
    var escapedSeparator, stringWithEscapedSeparators;
    if (separator == null) {
      separator = '/';
    }
    stringWithEscapedSeparators = UrlPattern.prototype.escapeSeparators(string, separator);
    stringWithEscapedSeparators = stringWithEscapedSeparators.replace(/\((.*?)\)/g, '(?:$1)?').replace(/\*/g, '(.*?)');
    escapedSeparator = UrlPattern.prototype.escapeForRegex(separator);
    UrlPattern.prototype.getNames(string, separator).forEach(function(name) {
      return stringWithEscapedSeparators = stringWithEscapedSeparators.replace(':' + name, "([^\\" + separator + "]+)");
    });
    return "^" + stringWithEscapedSeparators + "$";
  };
  return UrlPattern;
});
